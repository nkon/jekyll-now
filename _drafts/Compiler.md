---
layout: post
title: セルフホスト可能なCコンパイラを書く
category: blog
tags: c compiler
---

最近、コンパイラを書くことが流行っているようだ。流行に乗ってやってみたらいろいろな知見が得られたので紹介したい。

コンパイラを書くと一口に言ってもいろいろなスコープがある。ここでは、C言語を用いてCコンパイラを書くことを選択した。C言語は言語仕様的にコンパクトで広く知られている。また、ツールとしてのCコンパイラも普及している。その場合、自分が書いたCコンパイラで、自分が書いたCコンパイラのソースコードをコンパイルすることが原理的には可能だ。これをセルフホストという。ひとつの到達目標として非常に興味深い。

当初は冬の間に終わらせる予定だったのだが春まで伸びてしまった。しかし、春になっても寒かったり雨で家に居る日が多く、アウトドアシーズンまでに目標のセルフホストを達成することができた。

昔、Cのインタプリタを書いたことがあったが、コンパイラを書くのは、はじめてである。時代も進んで開発手法が変わったり、コンパイラ特有の技法があったり、いろいろと学びがあった。

# リソース



# 開発手法

9ccの作者が主張している開発方法はとても興味深い。実際にやってみて、その強力さを実感できた。一般的な開発手法として、どんなソフトウェア開発にも適用可能である。いますぐに、自分のプロジェクトに適用するべきだ。

## 非常に簡単なところから始め、つねに動く状態を保つ

フォーマルな開発手法では、仕様が会議などで定められ、仕様書ができたら開発が始まる。それは間違いだ。プログラムの機能や仕様は実装と密接に関係する。どんなに優秀なプログラマでも実装せずに仕様を確定すれば落とし穴や見落としがあるものだ。

拡張に拡張をかさねれば、スパゲッティでメンテナンス不能なプログラムになる恐れがある。しかし、それこそが技術力の差だ。適切なモジュール化を随時進めれば、スパゲッテイになることはない。また、モジュール化、リファクタリングをするのに絶対必要なツールが自動化されたテストだ。つまり、拡張したらメンテナス不能になるのは、テストを支えとしたリファクタリングが出来ないから、換言すればテストが無いから、であろう。

## 自動化されたテスト

現代の若者は、自動化されたテストは当然のものだと考えるだろう。私が最初に自動化テストに触れたのは2000年ごろの Perl コミュニティだ。当時 Perl はPerl4からPerl5変わろうとしていた時代だった。Perl5ではモジュールが導入され、モジュールのリポジトリであるCPAN登録するためには、自動化されたUnitテストが求められたのだ。

そこから20年、いまでは自動化されたユニットテストが当たり前だ。導入されていないのは私の職場ぐらいなものだろう。

* テストが自動化されていない。→テストは出荷前のリソースを大量投入した状態でしか行われないだろう。そして、テスト漏れと大量のバグが出る。開発者がテストを書き、それをもとに開発するしか、バグは防げない。

* テストを書くヒマが無い。ドキュメントを書くヒマが無い。→テストは実行可能な仕様書であり、自然言語よりも明確で完結だ。最もベストな方法はテストを書くこと。

* テストの書き方がよくわからない。→テストツールを導入すると学習コストがかかる。Rust などの現代的な言語ではテストが言語仕様に含まれているので迷いは無いはずだ。Cなどの古い言語でテストを実行するにはノウハウが必要だが、まずはカバレッジにこだわらず、とにかく自動実行することを考えよう。CppUTestは、機能は少ないが移植性は良く、良い選択しだと思う。

* テストをパスしているはずなのにバグが出た。→バグを再現するための最小構成のテストを書こう。一度書いたテストは自動実行され、エンバグ・デグレを防ぐ。



## 最初は正常系のみ

## Gitへのこまめなコミット

## デバッグ手法

デバッガでできること、というのはCPUのアーキテクチャと密接に関係していて、CPUのアーキテクチャは『ヘネ・パタ』以後、そう変わらない。デバッガに習得することは将来に応用可能な技術をえることができる。



コンパイラは複雑なピタゴラ装置みたいなものである。真に原因を探り当て、そこを正しく動作するようにすると、それまで全く動かなかったピタゴラ装置がいきなり稼働しだすというのは感動的な経験になるだろう。最初のドミノが倒れ、次のドミノが倒れるなら、その次も倒れる。再帰的構成法の偉大さを感じる瞬間でもある。

# コンパイラの技法

## lexer

## parser

## semantic analyzer

## preprocessor

## IR generator

## optimizer

## x86 generator

# 低レイヤ技術

## ABI(Application Binary Interface)

今回のコンパイラはアセンブラを出力する。それ以外のオプションとしては、Cを出力したり、最近ではLLVMの中間言語(IR)を出力したり、直接バイナリを出力したり。

ソースコードをコンパイルした結果、アセンブラを出力する。そのアセンブラは、アセンブラでコンパイルされる。つまり、アセンブラが理解できる書式で書かなければならない。アセンブラとしては、一般的な gas を使う。コマンドラインでは gcc(コンパイラドライバ)から起動する。せっかくコンパイラを書いたのに gcc を結局使うのだ。

アセンブラはオブジェクトファイルを出力する。オブジェクトファイルをライブラリとリンクしたら実行ファイルができる。ライブラリはシステム提供のもの、リンカは gcc のリンカ(これも gcc から起動する)を使う。

つまり、コンパイラの出力は、アセンブラが理解できるだけでなく、ライブラリを使って、システムのライブラリとリンク可能にしなければならない。そうでなければ、同じ x86 のアセンブラを出力したとしても、リンクで失敗する。

前置きが長いが、こういった相互運用を可能にするのが、ABI(Application Binary Interface)である。いくつかのABIが存在するが、今回は x86_64 ABI を使う。Linux 上で 64bit プログラムで使われている一般的な形式だ。ABIを守っていれば逆に、どんな言語で書いたオブジェクトファイルでもリンクできる。

x86_64 ABIは旧来のものとは違いレジスタをなるべく活用しようとする設計になっている。必然的に、コンパイラが出力するアセンブリコードも旧来のスタックマシンを前提としたものからレジスタマシンを前提としたものに変えていかなければならない。このへんは、わりと新しい技術だと思う。

主にコンパイラ研究やLLVM方面の成果だと思うが、レジスタマシンであっても最初は無限個のレジスタが使えるレジスタマシン向けのアセンブリ(またはIR:中間言語)を生成し、そこから現実のレジスタにフットさせるという手法が使われる。その段階で、とりあえずスタックに積んでおくという実装よりも、現実のレジスタ数に合わせて、かつ規約を守るように詰め込む、というより複雑なアルゴリズムが必要になる。Cが最初に開発された時代にはスタックマシンが一般的だったため、それに依存した可変個数引数と`<stdarg.h>`で定められる va_* マクロなどの仕様が紛れ込んでいる。





